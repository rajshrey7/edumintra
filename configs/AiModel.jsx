const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
  };
  

    export const GenerateCourseLayout_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate A Course Tutorial on Following Detail With field Course Name , Description, Along with Chapter Name, about, Duration: Category: \"Programming', Topic: Python, Level: Basic, Duration: 1 hour, NoOf Chapters:5, in JSON format"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"Name\": \"Python Fundamentals: A Beginner's Journey\",\n  \"Description\": \"This course is designed to introduce complete beginners to the world of Python programming.  You'll learn the basic syntax, data structures, and fundamental concepts necessary to write simple Python scripts and build a solid foundation for more advanced programming topics. No prior programming experience is required.\",\n  \"Category\": \"Programming\",\n  \"Topic\": \"Python\",\n  \"Level\": \"Basic\",\n  \"Duration\": \"5 hour\",\n  \"NoOfChapters\": 5,\n  \"Chapters\": [\n    {\n      \"ChapterName\": \"Chapter 1: Getting Started with Python\",\n      \"About\": \"This chapter covers the essentials of setting up your Python environment.  We'll explore how to download and install Python, configure a code editor (like VS Code or IDLE), and run your first Python program.  We'll also cover the basic syntax of Python and how to write comments.\",\n      \"Duration\": \"1 hour\",\n      \"Topics\": [\n        \"Installing Python\",\n        \"Setting up a code editor (VS Code, IDLE, etc.)\",\n        \"Writing your first Python program ('Hello, World!')\",\n        \"Understanding basic Python syntax (print statements, comments)\",\n        \"Python Documentation overview\"\n      ]\n    },\n    {\n      \"ChapterName\": \"Chapter 2: Variables, Data Types, and Operators\",\n      \"About\": \"In this chapter, you will learn about different data types in Python like integers, floats, strings, and booleans. We'll cover how to declare and assign variables, and explore various operators for performing arithmetic, comparison, and logical operations.\",\n      \"Duration\": \"1 hour\",\n      \"Topics\": [\n        \"Variables: Declaration and assignment\",\n        \"Data types: Integers, floats, strings, booleans\",\n        \"Arithmetic operators (+, -, *, /, %, //, **)\",\n        \"Comparison operators (==, !=, >, <, >=, <=)\",\n        \"Logical operators (and, or, not)\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Chapter 3: Control Flow: Making Decisions\",\n      \"About\": \"This chapter introduces control flow statements that allow your program to make decisions.  You'll learn about `if`, `elif`, and `else` statements, and how to use them to execute different blocks of code based on conditions.\",\n      \"Duration\": \"1 hour\",\n      \"Topics\": [\n        \"Conditional statements: `if`, `elif`, `else`\",\n        \"Nested `if` statements\",\n        \"Understanding Boolean logic in conditional statements\",\n        \"Writing programs with conditional branching\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Chapter 4: Loops: Repeating Tasks\",\n      \"About\": \"This chapter dives into loops, which allow you to repeat blocks of code multiple times. We'll cover `for` loops for iterating over sequences and `while` loops for repeating code based on a condition. We'll also discuss break and continue statements to control loop execution.\",\n      \"Duration\": \"1 hour\",\n      \"Topics\": [\n        \"`for` loops: Iterating over sequences (lists, strings, etc.)\",\n        \"`while` loops: Repeating code based on a condition\",\n        \"`break` and `continue` statements\",\n        \"Looping through range of numbers\",\n        \"Nested loops\"\n      ]\n    },\n    {\n      \"Chapter Name\": \"Chapter 5: Introduction to Data Structures: Lists\",\n      \"About\": \"This chapter introduces a fundamental data structure: lists. You'll learn how to create, access, modify, and iterate over lists. We'll also explore various list methods for common operations like adding, removing, and sorting elements.\",\n      \"Duration\": \"1 hour\",\n      \"Topics\": [\n        \"Creating lists\",\n        \"Accessing list elements (indexing)\",\n        \"Modifying lists (adding, removing, updating elements)\",\n        \"List methods (append, insert, remove, pop, sort, etc.)\",\n        \"Iterating over lists using `for` loops\",\n        \"List Slicing\"\n      ]\n    }\n  ]\n}\n```\n"},
          ],
        },
      ],
    });

    export const GenerateChapterContent_AI = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Explain the concept in Detail on Topic:+ DSA , Chapter:Data Structures, in JSON Format with list of array with field as title,  explanation in detail, Code Example(Code field in <precode> format) if applicable\n\n\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"topic\": \"Data Structures\",\n  \"chapters\": [\n    {\n      \"title\": \"Arrays\",\n      \"explanation\": \"Arrays are fundamental data structures used to store a collection of elements of the same data type in contiguous memory locations.  They provide a way to organize and access a fixed-size sequence of elements efficiently.  Key characteristics include: \\n\\n* **Homogeneity:** All elements in an array must be of the same data type (e.g., integers, strings, objects). \\n* **Contiguous Memory Allocation:** Elements are stored in adjacent memory locations, enabling fast access based on their index.\\n* **Fixed Size:**  The size of an array is typically determined at the time of creation (or declaration).  While dynamic arrays exist, they often involve resizing under the hood, which can have performance implications.  Static arrays have a fixed, compile-time size.\\n* **Index-based Access:** Elements are accessed using their index (or subscript), which is an integer value representing their position in the array, starting from 0 (zero-based indexing).  This makes array access very fast, usually O(1) complexity.\\n\\n**Operations on Arrays:**\\n\\n* **Access:** Retrieving the value of an element at a given index (O(1)).\\n* **Insertion:** Adding a new element to the array. This can be complex and potentially costly, especially in static arrays. In static arrays, typically, inserting at a specific index requires shifting existing elements to make space (O(n) in the worst case). Dynamic arrays handle this more efficiently (amortized O(1)).\\n* **Deletion:** Removing an element from the array. Similar to insertion, this can involve shifting elements to fill the gap left by the deleted element (O(n) in the worst case) for static arrays. Dynamic arrays handle this more efficiently (amortized O(1)).\\n* **Searching:** Finding a specific element in the array. Can be done using linear search (O(n)) or, if the array is sorted, using binary search (O(log n)).\\n* **Update:** Modifying the value of an element at a given index (O(1)).\\n\\n**Advantages of Arrays:**\\n\\n* **Efficient Access:**  Constant-time access to elements using their index.\\n* **Simple Implementation:** Relatively easy to understand and implement.\\n* **Cache-friendly:** Contiguous memory allocation makes arrays cache-friendly, leading to better performance.\\n\\n**Disadvantages of Arrays:**\\n\\n* **Fixed Size (for static arrays):**  Can be a limitation if the size of the data is unknown at the time of creation.\\n* **Inefficient Insertion/Deletion (in static arrays):** Inserting or deleting elements in the middle of the array can be time-consuming due to the need to shift elements.\\n* **Memory Waste:**  If the array is not fully utilized, memory can be wasted.\\n\\n**When to Use Arrays:**\\n\\n* When the size of the data is known in advance.\\n* When frequent access to elements by index is required.\\n* When memory efficiency is not a primary concern (or dynamic arrays are used intelligently).\\n\\n**Common Array Use Cases:**\\n\\n* Storing lists of data (e.g., names, ages, scores).\\n* Implementing other data structures, such as stacks, queues, and hash tables.\\n* Representing matrices and other multi-dimensional data.\",\n      \"code\": \"<pre><code># Python Example\\n\\n# Creating an array (list in Python)\\nmy_array = [1, 2, 3, 4, 5]\\n\\n# Accessing an element by index\\nprint(my_array[0])  # Output: 1\\n\\n# Updating an element\\nmy_array[2] = 10\\nprint(my_array)  # Output: [1, 2, 10, 4, 5]\\n\\n# Inserting an element (expensive in general, O(n) for lists in Python, best avoided if performance is critical)\\nmy_array.insert(1, 6) #Insert 6 at index 1\\nprint(my_array)\\n\\n# Deleting an element (expensive in general, O(n) for lists in Python, best avoided if performance is critical)\\ndel my_array[3] #Remove element at index 3\\nprint(my_array)\\n\\n# Iterating through the array\\nfor element in my_array:\\n    print(element)\\n\\n# Array length\\nprint(len(my_array))  # Output: 5\\n\\n#Java Example\\n// Java code\\n\\npublic class ArrayExample {\\n    public static void main(String[] args) {\\n        // Creating an array\\n        int[] myArray = new int[5]; // Fixed size of 5\\n\\n        // Initializing elements\\n        myArray[0] = 1;\\n        myArray[1] = 2;\\n        myArray[2] = 3;\\n        myArray[3] = 4;\\n        myArray[4] = 5;\\n\\n        // Accessing an element\\n        System.out.println(myArray[0]); // Output: 1\\n\\n        // Updating an element\\n        myArray[2] = 10;\\n        System.out.println(myArray[2]); // Output: 10\\n\\n        // Iterating through the array\\n        for (int i = 0; i < myArray.length; i++) {\\n            System.out.println(myArray[i]);\\n        }\\n    }\\n}\\n\\n// C++ example\\n\\n#include <iostream>\\n\\nint main() {\\n    // Creating an array\\n    int myArray[5] = {1, 2, 3, 4, 5};\\n\\n    // Accessing an element\\n    std::cout << myArray[0] << std::endl; // Output: 1\\n\\n    // Updating an element\\n    myArray[2] = 10;\\n    std::cout << myArray[2] << std::endl; // Output: 10\\n\\n    // Iterating through the array\\n    for (int i = 0; i < 5; i++) {\\n        std::cout << myArray[i] << std::endl;\\n    }\\n\\n    return 0;\\n}\\n</code></pre>\"\n    },\n    {\n      \"title\": \"Linked Lists\",\n      \"explanation\": \"A linked list is a linear data structure where elements, called nodes, are linked together using pointers. Unlike arrays, linked lists do not store elements in contiguous memory locations. Each node contains two parts: the data and a pointer (or reference) to the next node in the sequence.\\n\\n**Key Characteristics:**\\n\\n* **Dynamic Size:** Linked lists can grow or shrink dynamically as needed.  You don't need to predefine the size upfront.\\n* **Non-Contiguous Memory Allocation:** Nodes can be scattered in memory; the pointer links them together.\\n* **Nodes:** Each node contains the data and a pointer to the next node. The last node's pointer points to null (or nullptr).\\n* **Head:** The first node in the list is called the head.  It's essential for traversing the list.\\n* **Tail:** The last node in the list is called the tail.  It's optional to keep track of, but doing so can improve performance of operations like adding to the end of the list.\\n\\n**Types of Linked Lists:**\\n\\n* **Singly Linked List:** Each node has a pointer to the next node only.  Traversal is only possible in one direction.\\n* **Doubly Linked List:** Each node has pointers to both the next and previous nodes. This allows traversal in both directions.\\n* **Circular Linked List:** The last node's pointer points back to the head, forming a cycle.\\n\\n**Operations on Linked Lists:**\\n\\n* **Insertion:** Adding a new node to the list.  Insertion at the beginning or end can be very efficient (O(1)), especially if you keep track of the head and tail.  Insertion in the middle requires traversing to the desired position (O(n)).\\n* **Deletion:** Removing a node from the list.  Similar to insertion, deletion at the beginning can be O(1). Deletion in the middle requires traversal (O(n)).\\n* **Traversal:** Visiting each node in the list, typically starting from the head.  This is a fundamental operation (O(n)).\\n* **Searching:** Finding a specific node based on its data. Requires traversing the list (O(n)).\\n\\n**Advantages of Linked Lists:**\\n\\n* **Dynamic Size:** No need to predefine the size; memory is allocated as needed.\\n* **Efficient Insertion/Deletion:** Insertion and deletion at the beginning or in the middle (after locating the position) can be faster than arrays, especially when the insertion/deletion point is not at the end of a dynamic array.  No need to shift elements.\\n* **Memory Efficiency:** Allocate memory only for the nodes that are actually needed.\\n\\n**Disadvantages of Linked Lists:**\\n\\n* **Random Access Not Allowed:** Cannot access elements directly using an index like arrays.  Requires traversal from the head to reach a specific node (O(n)).\\n* **Extra Memory Overhead:** Each node requires extra memory for the pointer(s).\\n* **Cache Inefficiency:** Nodes are scattered in memory, which can lead to cache misses and slower performance.\\n\\n**When to Use Linked Lists:**\\n\\n* When the size of the data is unknown or changes frequently.\\n* When frequent insertion and deletion are required, especially in the middle of the list.\\n* When random access is not a primary requirement.\\n\\n**Common Linked List Use Cases:**\\n\\n* Implementing stacks and queues.\\n* Representing polynomial expressions.\\n* Managing dynamically allocated memory.\\n* Implementing graphs.\\n\",\n      \"code\": \"<pre><code># Python Example (Singly Linked List)\\n\\nclass Node:\\n    def __init__(self, data):\\n        self.data = data\\n        self.next = None\\n\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = None\\n\\n    def insert_at_beginning(self, data):\\n        new_node = Node(data)\\n        new_node.next = self.head\\n        self.head = new_node\\n\\n    def insert_at_end(self, data):\\n        new_node = Node(data)\\n        if self.head is None:\\n            self.head = new_node\\n            return\\n        last = self.head\\n        while (last.next):\\n            last = last.next\\n        last.next = new_node\\n\\n    def print_list(self):\\n        current = self.head\\n        while (current):\\n            print(current.data)\\n            current = current.next\\n\\n# Create a linked list\\nmy_list = LinkedList()\\n\\n# Insert elements\\nmy_list.insert_at_beginning(10)\\nmy_list.insert_at_end(20)\\nmy_list.insert_at_beginning(5)\\n\\n# Print the list\\nmy_list.print_list() # Output: 5 10 20\\n\\n# Java Example (Singly Linked List)\\n\\nclass Node {\\n    int data;\\n    Node next;\\n\\n    Node(int data) {\\n        this.data = data;\\n        this.next = null;\\n    }\\n}\\n\\nclass LinkedList {\\n    Node head;\\n\\n    LinkedList() {\\n        this.head = null;\\n    }\\n\\n    public void insertAtBeginning(int data) {\\n        Node newNode = new Node(data);\\n        newNode.next = head;\\n        head = newNode;\\n    }\\n\\n    public void insertAtEnd(int data) {\\n        Node newNode = new Node(data);\\n        if (head == null) {\\n            head = newNode;\\n            return;\\n        }\\n        Node last = head;\\n        while (last.next != null) {\\n            last = last.next;\\n        }\\n        last.next = newNode;\\n    }\\n\\n    public void printList() {\\n        Node current = head;\\n        while (current != null) {\\n            System.out.println(current.data);\\n            current = current.next;\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        LinkedList myList = new LinkedList();\\n        myList.insertAtBeginning(10);\\n        myList.insertAtEnd(20);\\n        myList.insertAtBeginning(5);\\n        myList.printList();\\n    }\\n}\\n\\n//C++ Example (Singly Linked List)\\n\\n#include <iostream>\\n\\nstruct Node {\\n    int data;\\n    Node* next;\\n};\\n\\nclass LinkedList {\\npublic:\\n    Node* head;\\n\\n    LinkedList() {\\n        head = nullptr;\\n    }\\n\\n    void insertAtBeginning(int data) {\\n        Node* newNode = new Node;\\n        newNode->data = data;\\n        newNode->next = head;\\n        head = newNode;\\n    }\\n\\n    void insertAtEnd(int data) {\\n        Node* newNode = new Node;\\n        newNode->data = data;\\n        newNode->next = nullptr;\\n\\n        if (head == nullptr) {\\n            head = newNode;\\n            return;\\n        }\\n\\n        Node* last = head;\\n        while (last->next != nullptr) {\\n            last = last->next;\\n        }\\n        last->next = newNode;\\n    }\\n\\n    void printList() {\\n        Node* current = head;\\n        while (current != nullptr) {\\n            std::cout << current->data << \\\" \\\";\\n            current = current->next;\\n        }\\n        std::cout << std::endl;\\n    }\\n};\\n\\nint main() {\\n    LinkedList myList;\\n    myList.insertAtBeginning(10);\\n    myList.insertAtEnd(20);\\n    myList.insertAtBeginning(5);\\n    myList.printList(); // Output: 5 10 20\\n    return 0;\\n}\\n</code></pre>\"\n    },\n        {\n      \"title\": \"Stacks\",\n      \"explanation\": \"A stack is a linear data structure that follows the Last-In, First-Out (LIFO) principle.  Imagine a stack of plates – you can only add or remove plates from the top.  The last plate you put on the stack is the first one you take off.\\n\\n**Key Characteristics:**\\n\\n* **LIFO (Last-In, First-Out):** The most recently added element is the first one to be removed.\\n* **Top:** The top of the stack is the location where elements are added or removed.\\n* **Push:** The operation of adding an element to the top of the stack.\\n* **Pop:** The operation of removing an element from the top of the stack.\\n* **Peek (or Top):**  An operation to examine the element at the top of the stack without removing it.\\n* **IsEmpty:**  An operation to check if the stack is empty.\\n* **IsFull:**  An operation to check if the stack is full (relevant for array-based implementations with a fixed size).\\n\\n**Operations on Stacks:**\\n\\n* **Push:** Adds an element to the top of the stack (O(1) - constant time).\\n* **Pop:** Removes and returns the element at the top of the stack (O(1) - constant time).\\n* **Peek:** Returns the element at the top of the stack without removing it (O(1) - constant time).\\n* **IsEmpty:** Checks if the stack is empty (O(1) - constant time).\\n* **IsFull (for fixed-size stacks):** Checks if the stack is full (O(1) - constant time).\\n\\n**Implementations of Stacks:**\\n\\n* **Array-based:** Stacks can be implemented using arrays.  This is simple but has the limitation of a fixed size (unless you use dynamic arrays that resize).  Need to keep track of the top index.\\n* **Linked List-based:** Stacks can also be implemented using linked lists.  This provides dynamic resizing, but adds the overhead of pointers.\\n\\n**Advantages of Stacks:**\\n\\n* **Simple Implementation:** Relatively easy to understand and implement.\\n* **Efficient Operations:** Push, pop, and peek operations are very fast (O(1)).\\n* **Memory Management:** Useful for managing function calls and local variables in programming languages (the call stack).\\n\\n**Disadvantages of Stacks:**\\n\\n* **Limited Access:**  You can only access the top element directly.  Accessing other elements requires popping elements off the stack until you reach the desired element.\\n* **Fixed Size (for array-based implementations):**  If using an array, you need to predefine the size.\\n\\n**When to Use Stacks:**\\n\\n* When you need to maintain a LIFO order of elements.\\n* When you need to track function calls in a program (call stack).\\n* When you need to implement backtracking algorithms.\\n* When you need to reverse a sequence of elements.\\n\\n**Common Stack Use Cases:**\\n\\n* Function call stack in programming languages.\\n* Expression evaluation (e.g., infix to postfix conversion).\\n* Undo/redo functionality in applications.\\n* Backtracking algorithms (e.g., solving mazes).\\n* Browser history (back button).\\n\",\n      \"code\": \"<pre><code># Python Example (Stack using a List)\\n\\nclass Stack:\\n    def __init__(self):\\n        self.items = []\\n\\n    def is_empty(self):\\n        return len(self.items) == 0\\n\\n    def push(self, item):\\n        self.items.append(item)\\n\\n    def pop(self):\\n        if not self.is_empty():\\n            return self.items.pop()\\n        else:\\n            return None  # Or raise an exception\\n\\n    def peek(self):\\n        if not self.is_empty():\\n            return self.items[-1]\\n        else:\\n            return None  # Or raise an exception\\n\\n    def size(self):\\n        return len(self.items)\\n\\n# Example Usage\\nmy_stack = Stack()\\nmy_stack.push(10)\\nmy_stack.push(20)\\nmy_stack.push(30)\\n\\nprint(my_stack.peek())  # Output: 30\\nprint(my_stack.pop())   # Output: 30\\nprint(my_stack.pop())   # Output: 20\\nprint(my_stack.is_empty()) # Output: False\\nprint(my_stack.pop())   #Output: 10\\nprint(my_stack.is_empty()) #Output: True\\n\\n# Java Example (Stack using LinkedList)\\n\\nimport java.util.LinkedList;\\n\\nclass Stack {\\n    private LinkedList<Integer> items;\\n\\n    public Stack() {\\n        items = new LinkedList<>();\\n    }\\n\\n    public boolean isEmpty() {\\n        return items.isEmpty();\\n    }\\n\\n    public void push(int item) {\\n        items.addFirst(item); // Add to the beginning for efficiency\\n    }\\n\\n    public Integer pop() {\\n        if (!isEmpty()) {\\n            return items.removeFirst(); // Remove from the beginning\\n        } else {\\n            return null; // Or throw an exception\\n        }\\n    }\\n\\n    public Integer peek() {\\n        if (!isEmpty()) {\\n            return items.getFirst();\\n        } else {\\n            return null; // Or throw an exception\\n        }\\n    }\\n\\n    public int size() {\\n        return items.size();\\n    }\\n\\n    public static void main(String[] args) {\\n        Stack myStack = new Stack();\\n        myStack.push(10);\\n        myStack.push(20);\\n        myStack.push(30);\\n\\n        System.out.println(myStack.peek());  // Output: 30\\n        System.out.println(myStack.pop());   // Output: 30\\n        System.out.println(myStack.pop());   // Output: 20\\n        System.out.println(myStack.isEmpty()); // Output: false\\n        System.out.println(myStack.pop()); // Output: 10\\n        System.out.println(myStack.isEmpty()); // Output: true\\n    }\\n}\\n\\n// C++ Example (Stack using std::stack)\\n\\n#include <iostream>\\n#include <stack>\\n\\nint main() {\\n    std::stack<int> myStack;\\n\\n    myStack.push(10);\\n    myStack.push(20);\\n    myStack.push(30);\\n\\n    std::cout << myStack.top() << std::endl; // Output: 30\\n    myStack.pop();\\n    std::cout << myStack.top() << std::endl; // Output: 20\\n    myStack.pop();\\n    std::cout << myStack.top() << std::endl; // Output: 10\\n    myStack.pop();\\n\\n    if (myStack.empty()) {\\n        std::cout << \\\"Stack is empty\\\" << std::endl; // Output: Stack is empty\\n    } else {\\n        std::cout << \\\"Stack is not empty\\\" << std::endl;\\n    }\\n\\n    return 0;\\n}\\n</code></pre>\"\n    },\n    {\n      \"title\": \"Queues\",\n      \"explanation\": \"A queue is a linear data structure that follows the First-In, First-Out (FIFO) principle. Imagine a queue of people waiting in line – the first person to join the line is the first person to be served.  New elements are added to the *rear* of the queue, and elements are removed from the *front*.\\n\\n**Key Characteristics:**\\n\\n* **FIFO (First-In, First-Out):** The first element added to the queue is the first one to be removed.\\n* **Front:** The front of the queue is the location from which elements are removed.\\n* **Rear:** The rear (or back) of the queue is the location where elements are added.\\n* **Enqueue:** The operation of adding an element to the rear of the queue.\\n* **Dequeue:** The operation of removing an element from the front of the queue.\\n* **Peek (or Front):**  An operation to examine the element at the front of the queue without removing it.\\n* **IsEmpty:**  An operation to check if the queue is empty.\\n* **IsFull:** An operation to check if the queue is full (relevant for array-based implementations with a fixed size).\\n\\n**Operations on Queues:**\\n\\n* **Enqueue:** Adds an element to the rear of the queue (O(1) on average). In a circular queue with a fixed size array, enqueue can be O(n) if resizing is required.\\n* **Dequeue:** Removes and returns the element at the front of the queue (O(1)).\\n* **Peek:** Returns the element at the front of the queue without removing it (O(1)).\\n* **IsEmpty:** Checks if the queue is empty (O(1)).\\n* **IsFull (for fixed-size queues):** Checks if the queue is full (O(1)).\\n\\n**Implementations of Queues:**\\n\\n* **Array-based:** Queues can be implemented using arrays. This is relatively simple, but can be inefficient if the queue grows and shrinks frequently, as it requires shifting elements when dequeuing (unless you use a circular queue).  Requires keeping track of front and rear indices.\\n* **Linked List-based:** Queues can also be implemented using linked lists. This provides dynamic resizing and avoids the need to shift elements, but adds the overhead of pointers.\\n* **Circular Queue:** A variation of the array-based queue where the front and rear pointers wrap around the array, allowing you to reuse space that has been dequeued.  More efficient than a simple array-based queue when the queue fluctuates in size.\\n\\n**Advantages of Queues:**\\n\\n* **FIFO Order:** Ensures that elements are processed in the order they were added.\\n* **Fairness:** Useful for scheduling tasks and ensuring that all tasks are eventually processed.\\n\\n**Disadvantages of Queues:**\\n\\n* **Limited Access:** You can only access the front element directly. Accessing other elements requires dequeuing elements until you reach the desired element.\\n* **Potential Inefficiency (array-based):** Shifting elements during dequeuing in array-based implementations can be time-consuming if not implemented as a circular queue.\\n\\n**When to Use Queues:**\\n\\n* When you need to maintain a FIFO order of elements.\\n* When you need to schedule tasks in a fair manner.\\n* When you need to implement breadth-first search algorithms.\\n* When you need to process data in the order it is received.\\n\\n**Common Queue Use Cases:**\\n\\n* Task scheduling in operating systems.\\n* Print queues.\\n* Message queues in distributed systems.\\n* Breadth-first search (BFS) algorithms.\\n* Handling network requests.\\n* Customer service call centers (call queue).\\n\",\n      \"code\": \"<pre><code># Python Example (Queue using a List)\\n\\nclass Queue:\\n    def __init__(self):\\n        self.items = []\\n\\n    def is_empty(self):\\n        return len(self.items) == 0\\n\\n    def enqueue(self, item):\\n        self.items.append(item)\\n\\n    def dequeue(self):\\n        if not self.is_empty():\\n            return self.items.pop(0)  # Remove from the front (index 0)\\n        else:\\n            return None  # Or raise an exception\\n\\n    def peek(self):\\n        if not self.is_empty():\\n            return self.items[0]  # Get the element at the front\\n        else:\\n            return None  # Or raise an exception\\n\\n    def size(self):\\n        return len(self.items)\\n\\n# Example Usage\\nmy_queue = Queue()\\nmy_queue.enqueue(10)\\nmy_queue.enqueue(20)\\nmy_queue.enqueue(30)\\n\\nprint(my_queue.peek())  # Output: 10\\nprint(my_queue.dequeue())   # Output: 10\\nprint(my_queue.dequeue())   # Output: 20\\nprint(my_queue.is_empty()) # Output: False\\nprint(my_queue.dequeue())   # Output: 30\\nprint(my_queue.is_empty()) # Output: True\\n\\n# Java Example (Queue using LinkedList)\\n\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\npublic class QueueExample {\\n    public static void main(String[] args) {\\n        Queue<Integer> myQueue = new LinkedList<>();\\n\\n        myQueue.enqueue(10);\\n        myQueue.enqueue(20);\\n        myQueue.enqueue(30);\\n\\n        System.out.println(myQueue.peek());  // Output: 10\\n        System.out.println(myQueue.dequeue());   // Output: 10\\n        System.out.println(myQueue.dequeue());   // Output: 20\\n        System.out.println(myQueue.isEmpty()); // Output: false\\n        System.out.println(myQueue.dequeue());   // Output: 30\\n        System.out.println(myQueue.isEmpty()); // Output: true\\n\\n    }\\n    static class Queue<T> {\\n        private LinkedList<T> items;\\n\\n        public Queue() {\\n            items = new LinkedList<>();\\n        }\\n\\n        public boolean isEmpty() {\\n            return items.isEmpty();\\n        }\\n\\n        public void enqueue(T item) {\\n            items.addLast(item);\\n        }\\n\\n        public T dequeue() {\\n            if (!isEmpty()) {\\n                return items.removeFirst();\\n            } else {\\n                return null; // Or throw an exception\\n            }\\n        }\\n\\n        public T peek() {\\n            if (!isEmpty()) {\\n                return items.peekFirst();\\n            } else {\\n                return null; // Or throw an exception\\n            }\\n        }\\n    }\\n}\\n\\n// C++ Example (Queue using std::queue)\\n\\n#include <iostream>\\n#include <queue>\\n\\nint main() {\\n    std::queue<int> myQueue;\\n\\n    myQueue.enqueue(10);\\n    myQueue.enqueue(20);\\n    myQueue.enqueue(30);\\n\\n    std::cout << myQueue.front() << std::endl; // Output: 10\\n    myQueue.dequeue();\\n    std::cout << myQueue.front() << std::endl; // Output: 20\\n    myQueue.dequeue();\\n    std::cout << myQueue.front() << std::endl; // Output: 30\\n    myQueue.dequeue();\\n\\n    if (myQueue.empty()) {\\n        std::cout << \\\"Queue is empty\\\" << std::endl; // Output: Queue is empty\\n    } else {\\n        std::cout << \\\"Queue is not empty\\\" << std::endl;\\n    }\\n\\n    return 0;\\n}\\n</code></pre>\"\n    },\n     {\n      \"title\": \"Hash Tables (Hash Maps)\",\n      \"explanation\": \"A hash table (also known as a hash map) is a data structure that implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.\\n\\n**Key Concepts:**\\n\\n* **Key-Value Pairs:** Hash tables store data as key-value pairs. Each key is unique within the table, and it's associated with a specific value.\\n* **Hash Function:** A function that takes a key as input and returns an integer value, called the hash code.  The hash code is used as an index into the array.\\n* **Array (Buckets/Slots):** The underlying storage for the key-value pairs. The array is divided into buckets or slots.\\n* **Collision:** When two different keys produce the same hash code, it's called a collision.\\n* **Collision Resolution:** Strategies for handling collisions (e.g., separate chaining, open addressing).\\n\\n**Collision Resolution Techniques:**\\n\\n* **Separate Chaining:** Each bucket in the array points to a linked list (or another data structure) that stores all the key-value pairs that hash to that bucket.  Simple and common.\\n* **Open Addressing:** When a collision occurs, the algorithm probes for an empty slot in the array. Common techniques include linear probing, quadratic probing, and double hashing.  Can suffer from clustering (where collisions lead to more collisions in nearby slots).\\n\\n**Operations on Hash Tables:**\\n\\n* **Insert (Put):** Adds a new key-value pair to the table.  The key is hashed, and the value is stored in the corresponding bucket (O(1) on average, but O(n) in the worst case with separate chaining if all keys hash to the same bucket, or with open addressing if many collisions occur and the table is nearly full).\\n* **Get:** Retrieves the value associated with a given key. The key is hashed, and the bucket is searched (O(1) on average, but O(n) in the worst case for the same reasons as insert).\\n* **Delete (Remove):** Removes the key-value pair associated with a given key (O(1) on average, O(n) in the worst case).\\n* **Search (ContainsKey):** Checks if a given key exists in the table (O(1) on average, O(n) in the worst case).\\n\\n**Advantages of Hash Tables:**\\n\\n* **Fast Average-Case Performance:** Insert, get, delete, and search operations have an average time complexity of O(1), making them very efficient for many applications.\\n* **Dynamic Size:** Hash tables can grow dynamically to accommodate a large number of key-value pairs.\\n* **Flexibility:** Can store any type of data (as values).\\n\\n**Disadvantages of Hash Tables:**\\n\\n* **Worst-Case Performance:** In the worst case (e.g., all keys hash to the same bucket), operations can degrade to O(n).\\n* **Space Overhead:** Hash tables require extra space for the array and potentially for collision resolution structures (like linked lists).\\n* **Hash Function Importance:** The performance of a hash table depends heavily on the quality of the hash function. A poorly designed hash function can lead to frequent collisions and poor performance.\\n* **Unordered Data:** Hash tables do not maintain any specific order of elements.  If you need ordered data, consider using a different data structure (e.g., a tree-based map).\\n\n**When to Use Hash Tables:**\\n\\n* When you need fast average-case performance for insert, get, delete, and search operations.\\n* When you need to store and retrieve data based on a key.\\n* When the order of elements is not important.\\n\\n**Common Hash Table Use Cases:**\\n\\n* Implementing dictionaries and symbol tables.\\n* Caching data.\\n* Database indexing.\\n* Implementing sets (using only keys).\\n* Counting the frequency of elements.\\n\",\n      \"code\": \"<pre><code># Python Example (Dictionary - built-in Hash Table)\\n\\n# Creating a dictionary\\nmy_dict = {}\\n\\n# Inserting key-value pairs\\nmy_dict['apple'] = 1\\nmy_dict['banana'] = 2\\nmy_dict['cherry'] = 3\\n\\n# Accessing values\\nprint(my_dict['apple'])  # Output: 1\\n\\n# Checking if a key exists\\nprint('apple' in my_dict)  # Output: True\\n\\n# Deleting a key-value pair\\ndel my_dict['banana']\\n\\nprint(my_dict) #Output: {'apple': 1, 'cherry': 3}\\n\\n# Iterating through the dictionary\\nfor key, value in my_dict.items():\\n    print(key, value)\\n\\n# Java Example (HashMap)\\n\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class HashMapExample {\\n    public static void main(String[] args) {\\n        // Creating a HashMap\\n        Map<String, Integer> myMap = new HashMap<>();\\n\\n        // Inserting key-value pairs\\n        myMap.put('apple', 1);\\n        myMap.put('banana', 2);\\n        myMap.put('cherry', 3);\\n\\n        // Accessing values\\n        System.out.println(myMap.get('apple')); // Output: 1\\n\\n        // Checking if a key exists\\n        System.out.println(myMap.containsKey('apple')); // Output: true\\n\\n        // Deleting a key-value pair\\n        myMap.remove('banana');\\n\\n        System.out.println(myMap);  // Output: {apple=1, cherry=3}\\n\\n        //"},
          ],
        },
      ],
    });
  
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // console.log(result.response.text());
 